require 'active_record'
require 'logger'
require 'pg'
require 'yaml'

require 'standalone_migrations'
StandaloneMigrations::Tasks.load_tasks

module LT
  module Janitor
    class << self
      # run_env holds running environment: production|staging|test|development
      # root_dir holds application root (where this Rake file is located)
      attr_accessor :run_env, :logger, :root_dir, :model_path
    end
  end # Janitor
end # LT

desc 'Default does nothing at the moment - just used to check if rake compiles'
task :default do
  puts "Default task complete."
end

namespace :lt do
  namespace :janitor do
    desc "Boot Janitor system"
    task :boot => [:'boot:set_env', :'boot:setup_logger', :'boot:boot_janitor_db', :'boot:load_all_models'] do
      LT::Janitor::logger.info("Janitor booted")
    end
    desc "Seed environment db with data"
    task :seed => [:'boot', :'db:seed']

    # holds all our bootup tasks
    namespace :boot do
      desc "Setup janitor logger"
      task :setup_logger do
        LT::Janitor.logger = Logger.new($stdout)
      end

      desc "Define the environment we are running in (prod, test, dev)"
      task :set_env do
        # note StandaloneMigrations doesn't honor anything but ENV[RAILS_ENV]
        # so you have to set your environment variable despite what the 
        # following line implies. E.g., export RAILS_ENV=development
        # OR rake [task] RAILS_ENV=development
        LT::Janitor::run_env = ENV['RAILS_ENV'] || ENV['RACK_ENV'] || 'development'
        LT::Janitor::root_dir = File::expand_path(Rake.application.original_dir)
        LT::Janitor::model_path = File::join(LT::Janitor::root_dir, '/lib/model') 
      end
      
      desc "Load all AR models from ./lib/model"
      task :load_all_models do
        models = Dir::glob(File::join(LT::Janitor::model_path, '*.rb'))
        models.each do |file| 
          full_file =  File::join(LT::Janitor::model_path, File::basename(file))
          require full_file
        end
      end

      desc "Establish connection to janitor database"
      task :boot_janitor_db do
        # Connect to DB
        begin
          dbconfig = YAML::load(File.open('db/config.yml'))
          ActiveRecord::Base.establish_connection(dbconfig[LT::Janitor::run_env])
        rescue Exception => e
          LT::Janitor::logger.error("Cannot connect to Postgres, connect string: #{dbconfig['development']}, error: #{e.message}")
          # SM: Re-raising an error is better than eating it, IMO, so I'm removing the abort
          raise e
          #abort()
        end
      end # boot_janitor_db
    end #boot
  end # janitor
end # lt



